[{"content":"Introduction\rAs monolinguals, we face a lot of difficulties in IELTS.\nEnglish is not solid （基础差）\nNot familiar with IELTS （不懂考点）\nDon\u0026rsquo;t want to pay just want to escape（不想努力）\nTherefore, we can improve listening from the following there aspects.\nEnglish basis\rFirst, vocabulary is required. Then need to the spelling and pronunciation of each word.\n这里我使用墨墨背单词\n2 What\u0026rsquo;s on the IELTS listening? Difficulties in Listening\ntrap choice (陷阱选项)\nThe negation appears inaudible （听不到）\nDon\u0026rsquo;t understand the original text （不懂内容）\nThere is no detection of stealing the subject （没注意替换）\nIn general, this is considered as follows\nWords can be read and write Words can distinguish pronunciation and meaning Sentences can be read and translated Understand logical relationships Be familiar with substitutions and rephrasing Be clear about the test format Carefully prejudge the topic I think reading and writing words is the foundation, logical relationships and substitutions are key. (单词是基础，逻辑关系和替换是关键)\nHow to practice listening efficiency?\rFirst of all, there are four types of IELTS listening questions. They are fill-in-the-blank, map, matching, single-choice, and multiple-choice. There are tips and considerations for each type of question.\nFill-in-the-blank\rSteps:\nLook at the word limit （看题目单词限制） Circle the positioning words in the order of question number （划定位词） Circled words can be pronounced （知道被圈词的发音） Predict the content of the blank by circling （预测要填空的词） Write the blank considering whether it is plural or not （判断填空词的复数形式） the positioning word are usually the first and after two\nMore stable: number, noun, proper noun\nUnstable: adjective, verb\nTrap: adjective, common antonyms, negative words\nMap\rSteps:\nMark directions (such as top, bottom, left and right, or east, west, north and south) （标记方位） Circle all the place names and know the pronunciation （圈出地名并知道发音） Mark the picture in the order of question number （按顺序标记问题） If the topic stem is in lowercase, it may not be directly addressable （如果题目是小写，可能发送改写） Pay attention to the logical relation link words and answer （注意逻辑关系词） Sometimes there will be a fill-in-the-blank-map, the method is also applicable.\nMatching\rSteps:\nFind the positioning words in the choices (not repeated and non-specific words) （找定位词） Pay attention to logical relationships （注意逻辑关系） However, we should be paid to logical relation words and synonymous substitutions\nLogical relation\nParalleling\nand, also, as well as, then, another, anything else? is that all?\nComparison\nat the same time\nOrder\nfirstly, then, after that, lastly, and finally\nExplanation\nI mean, this means, in other words, for instance\nExamples\nsuch as, like, for example\nTurn\nbut, however, all of a sudden, whereas\nCause and Effect\nbecause, since, so, therefore\nEmphasis\nin fact, actually, especially, do + (verb), of course, important\nParenthesis\nlet me see, you know...\nNew Topic\nnow, anyway\nSupplement\nOh, hang on, wait a minute\nSynonymous substitutions\nShort rephrased\nChange the property of the word\nreduce = reduction\nSynonyms\nreduce = fail = dive - go down = decrease = decline\nSimilar words\nassignment = presentation = essay = reflect (paper)\nhash brown = chips = french fries = potato (food)\nExplain\nbuying things = shop\nDouble negatives\nnot good = bad\nPronoun substitution\nJames = he\nContext\nfirst = succeed\nInvert\nTom's books = the books of Tom\npriority for revision = revision priority\nLong rephrased\nA = B\nPassive = Active\nsingle-choice \u0026amp; multiple-choice\rSteps:\nRead and mark the question （优先看完问题，审题）\nUnderline test points, pay attention to substitution, Know the pronunciation （考点划线，注意改写，生词猜发音）\nMake notes when listening （边听边做记号）\nTips\nThree major positioning methods\nDon\u0026rsquo;t understand + choice original word = trap\nIt\u0026rsquo;s safer to hear rewrites\nPay attention to the juxtaposition of options\nPay attention to the identity and gender of the person speaking\nFocus on positioning\nThe original word in the question\nLogical connectives\nRephrase the question\nSummary\rTry to look at all the choices （题目选项尽量都看）\nLook and draw a circle （边看边画圈预判）\nLook at each section in order of question number （每个部分按题号顺序看）\nNotice the timing （注意时间）\nThe third part is most difficult to recommend squeezing in time to see in advance （第三部分最难建议挤时间提前看）\n","date":"2023-08-04T00:00:00Z","image":"http://localhost:1313/p/necessary-skills-of-ielts-listening/382f0a22-149c-4983-8de0-6495bea6fc88_hu_3b16c43ff0a8a923.jpeg","permalink":"http://localhost:1313/p/necessary-skills-of-ielts-listening/","title":"Necessary skills of IELTS (LISTENING)"},{"content":"前言\r第二章为Program Structure（程序结构），通过7个部分的示例代码深入讨论Go程序基础结构方面的一些细节。第二章课后练习比较基础，了解Go语言程序结构即可完成。\n本章所有示例代码链接 ch2 (有需自取，这里不做演示)\n课后练习\rPackages and Files\r示例代码是一个进行摄氏度和华氏度转换的程序，课后练习如下\n练习 2.1： 向tempconv包添加类型、常量和函数用来处理Kelvin绝对温度的转换，Kelvin 绝对零度是−273.15°C，Kelvin绝对温度1K和摄氏度1°C的单位间隔是一样的。\n思路\n类似摄氏度和华氏度之间的转换，将开尔文与其转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // tempconv.go in the tempconv package type Celsius float64 type Fahrenheit float64 type Kelvin float64 const ( AbsoluteZeroC Celsius = -273.15 freezingF Celsius = 0 boilingC Celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\u0026#34;%g°C\u0026#34;, c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\u0026#34;%g°F\u0026#34;, f) } func (k Kelvin) String() string { return fmt.Sprintf(\u0026#34;%g°K\u0026#34;, k) } func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } func KToC(k Kelvin) Celsius { return Celsius(k) - AbsoluteZeroC } func CToK(c Celsius) Kelvin { return Kelvin(c + AbsoluteZeroC) } func FToK(f Fahrenheit) Kelvin { return kelvin(KToC(f) + AbsoluteZeroC) } func KToF(k Kelvin) Fahrenheit { return CTok(Celsius(k) - AbsoluteZeroC) } Imports\r示例代码是一个调用tempconv包中转换函数的程序，课后练习如下\n练习 2.2： 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。\n思路\n这里以英尺和米的转换为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Meter float64 type Foot float64 func (m Meter) String() string { return fmt.Sprintf(\u0026#34;%fm\u0026#34;, m) } func (f Foot) String() string { return fmt.Sprintf(\u0026#34;%fft\u0026#34;, f) } func (m Meter) MToF() Foot { return Foot(m / 0.3084) } func (f Foot) FToM() Meter { return Meter(f * 0.3084) } Package Initialization\r示例代码是一个统计二进制数学中bit为1个数的程序，其中使用init方法初始化程序，课后练习如下。\n练习 2.3： 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）\n练习 2.4： 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异。\n练习 2.5： 表达式x\u0026amp;(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能。\n思路\n用for循环代替原函数的暴力相加即可。使用移位算法，通过x\u0026amp;1计算最低位是否为1，然后执行x\u0026gt;\u0026gt;1移位，依次统计为1的次数即可。使用表达式x\u0026amp;(x-1)可以将x的最低的一个非零bit位清零，因此只需统计执行次数即可。至于性能判断，通过time包下的Now()和Since()方法比较不同函数执行时间即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func PopCount2(x uint64) int { var res int for i := 1; i \u0026lt; 8; i++ { res += int(pc[byte(x\u0026gt;\u0026gt;(i*8))]) } return res } // count each bit func PopCount3(x uint64) int { var res int for x \u0026gt; 0 { if x\u0026amp;1 == 1 { res++ } x \u0026gt;\u0026gt;= 1 } return res } // x \u0026amp; (x - 1) func PopCount4(x uint64) int { var res int for x \u0026gt; 0 { x \u0026amp;= (x - 1) res++ } return res } ","date":"2023-07-31T00:00:00Z","image":"http://localhost:1313/p/the-go-programming-language-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-ch.2/ab638d52-5f92-4e29-955e-064deb1c4728_hu_42190784e75fa0e4.jpeg","permalink":"http://localhost:1313/p/the-go-programming-language-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-ch.2/","title":"The Go Programming Language 课后练习 Ch.2"},{"content":"前言\r第一章为Tutorial（教程），通过8个部分的示例代码带领读者熟悉Go语言的语法和规则。第一章课后练习比较基础，熟悉基本语法规则即可完成。\n本章所有示例代码链接 Ch1 (有需求自取，就不给出示例代码了。。。)\n课后练习\rCommand-Line Arguments\r示例代码是一个打印命令行参数的程序，课后练习如下\n练习 1.1： 修改 echo 程序，使其能够打印 os.Args[0]，即被执行命令本身的名字\n练习 1.2： 修改 echo 程序，使其打印每个参数的索引和值，每个一行。\n练习 1.3： 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）\n思路\n这三个练习还是非常基础的，利用for range遍历os.Args[0:]切片即可，range会返回元素和该元素对应的下标（从0开始）。示例代码中使用字符串拼接的方式来获取命令行参数结果，但其实这是一种效率非常低的方法，因此另一个示例代码用stirngs.Join方法拼接字符串，这是一种更高效的方法（原因参考原文）。为了测试两种方式的效率，使用time包中的Now()和Since()方法即可获得程序运行时间，比较运行时间即可测评性能。\n1 2 3 4 5 func main() { for i, arg := range os.Args[0:] { fmt.Printf(\u0026#34;index = %d, value = %s\\n\u0026#34;, i, arg) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { start := time.Now() s, sep := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; for _, arg := range os.Args[0:] { s += sep + arg sep = \u0026#34; \u0026#34; } fmt.Println(s) // strings.Join // fmt.Println(strings.Join(os.Args[0:], \u0026#34; \u0026#34;)) total := time.Since(start) fmt.Printf(\u0026#34;runing time = %s\\n\u0026#34;, total) } Finding Duplicate Lines\r示例代码是一个读取标准输入流或者命令行参数中的文件, 并找出重复行的程序。课后练习如下\n练习 1.4： 修改 dup2，出现重复的行时打印文件名称。\n思路\n原代码通过维护一个map来记录每行的内容和出现次数，因此需维护另一个map来记录每行内容和出现该内容的file数组。最后在输出重复行时，将file数组一同输出即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // if target in strs func contains(strs []string, target string) bool { for _, str := range strs { if str == target { return true } return false } // find duplicate line func countLines(f *os.File, counts map[string]int, filename map[string][]string) { intput := bufio.NewScanner(f) for input.Scan() { str := input.Text() counts[str]++ if filename == nil { filename[str] = make([]string, 0) } if !contains(filename[str], f.Name()) { filename[str] = append(filename[str], f.Name()) } } func main() { counts := make(map[string]int) filename := make(map[string][]string) files := os.Args[1:] if len(files) == 0 { countLines(os.Stdin, counts, filename) } else { for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;dup2: %v\\n\u0026#34;, err) continue } // dup line countLines(f, counts, filename) f.Close() } } // output info for line, n := range counts { if n \u0026gt; 1 { fmt.Printf(\u0026#34;%d\\t%s\\t%v\\n\u0026#34;, n, line, filename[line]) } } } Animated GIFs\r示例代码是一个利用sin函数和cos函数打印利萨如图形（Lissajous figures）的程序。课后练习如下\n练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。\n练习 1.6： 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。\n思路\npalette数组为图形调色板，SetColorIndex函数第三个参数对应调色板颜色的下标。将七彩色放入调色板，每次运行后改变颜色即可得到RGBGIF。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var palette = []color.Color{ //color.Black, color.White, color.RGBA{0xff, 0x00, 0x00, 0xff}, color.RGBA{0xff, 0x7d, 0x00, 0xff}, color.RGBA{0xff, 0xff, 0x00, 0xff}, color.RGBA{0x00, 0xff, 0x00, 0xff}, color.RGBA{0x00, 0x00, 0xff, 0xff}, color.RGBA{0x00, 0xff, 0xff, 0xff}, color.RGBA{0xff, 0x00, 0xff, 0xff}, } func lissajous(out io.Writer) { const ( cycles = 5 res = 0.001 size = 100 nframes = 64 delay = 8 ) freq := rand.Float64() * 3.0 anim := gif.GIF{LoopCount: nframes} phase := 0.0 colorIndex := 1 for i := 0; i \u0026lt; nframes; i++ { rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), uint8(colorIndex)) } colorIndex = (colorIndex % 7) + 1 phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) } gif.EncodeAll(out, \u0026amp;anim) } Fetching a URL\r示例代码是一个获取对应的url，发送http请求，并将其源文本打印出来的程序，课后练习如下\n练习 1.7： 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。\n练习 1.8： 修改fetch这个范例，如果输入的url参数没有 http:// 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。\n练习 1.9： 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。\n思路\n这三个练习较为基础，用io.Copy代替ioutill.ReadAll，将返回信息输出到stdout中。通过strings.HasPrefix来判断url是否有http://前缀，没有就加上。最后打印resp.Status即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { for _, url := range os.Args[1:] { if !strings.HasPrefix(url, \u0026#34;http://\u0026#34;) { url = \u0026#34;http://\u0026#34; + url } resp, err := http.Get(url) if err != nil { fmt.Fprint(os.Stderr, \u0026#34;fetch: %v\\n\u0026#34;, err) os.Exit(1) } //b, err := ioutil.ReadAll(resp.Body) fmt.Printf(\u0026#34;http status: %s\\n\u0026#34;, resp.Status) b, err := io.Copy(os.Stdout, resp.Body) resp.Body.Close() if err != nil { fmt.Fprint(os.Stderr, \u0026#34;fetch: iocopy %s: %v\\n\u0026#34;, url, err) os.Exit(1) } fmt.Printf(\u0026#34;%d\\n\u0026#34;, b) } } Fetching URLS Concurrently\r示例代码和上一小节程序所要做的工作基本一致，但fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面程序执行时间则是所有任务执行时间之和。课后练习如下\n练习 1.10： 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。\n练习 1.11： 在fetchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。\n思路\n这里涉及的内容为计算机网络内容，个人无法给出规范答案，因此由ChatGPT作答\n1.10\n根据网站的缓存策略，对每个URL执行两遍请求，两次执行时间可能会有较大的差别，这取决于缓存的设置和实际的网络环境。当涉及到缓存的情况时，以下两种情况是可能的：\n第一次请求：如果该URL的响应之前没有被缓存，服务器将会生成响应并将其返回给客户端。在这种情况下，第一次请求可能会比较慢，因为服务器需要处理请求并生成响应。\n第二次请求：如果该URL的响应被缓存了，服务器会直接返回缓存的响应，而无需再次处理请求。在这种情况下，第二次请求通常会比较快，因为省去了服务器重新生成响应的步骤。\n因此，第一次请求通常比第二次请求慢，但具体的差别取决于缓存策略、缓存的生存时间以及服务器和网络的负载等因素。\n关于响应内容的一致性，如果两次请求之间没有发生数据变化，并且没有其他中间因素影响响应内容，那么两次获取到的响应内容应该是一致的。这是因为缓存是根据URL或其他标识来存储响应的，如果请求的标识相同，那么缓存会返回相同的响应内容。 然而，需要注意以下几点：\n如果两次请求之间的数据发生了变化（例如，某些数据被更新了），则两次响应的内容可能会不一致，因为第二次请求获取到的是最新的数据。\n如果网站的缓存策略是根据时间来进行刷新，那么两次请求之间的时间间隔较长，第二次请求可能会从服务器上获取到更新后的响应内容。\n在多服务器或负载均衡环境中，两次请求可能被分发到不同的服务器上，导致两次响应内容不一致，这取决于服务器之间是否共享缓存。\n综上所述，根据网站的缓存策略，两次请求的执行时间可能有较大的差别，并且每次获取到的响应内容在一些特定情况下可能会不一致。但在正常情况下，如果两次请求之间没有发生变化并且没有其他中间因素干扰，响应内容应该是一致的。\n1.11\n在fetchall代码中，如果尝试使用长一些的参数列表，例如使用在 Alexa 排名靠前的上百万网站作为URL列表，当其中某个网站没有回应时，程序的行为将根据并发请求的方式来决定。\n根据目前给出的代码，fetchall是使用一个简单的循环来依次请求每个URL的，因此程序会按照顺序一个一个地发送请求。在这种情况下，如果一个网站没有回应，程序会出现阻塞等待的情况，直到该请求超时或获得响应。\n具体表现如下：\n阻塞等待：当程序发起请求并没有获得响应时，程序会一直等待，直到超过了设置的请求超时时间。这可能会导致程序执行时间较长，尤其在长列表中有多个未响应的网站时。\n超时报错：如果请求超时，http.Get方法会返回一个错误，指示请求超时。在代码中，该错误会被捕获，并在标准错误输出中打印出来。随后，程序继续执行下一个请求。\n值得注意的是，超时时间的设置在当前给出的代码中并未体现。对于大规模请求或长列表，设置合理的超时时间是非常重要的。如果没有设置超时时间，程序在遇到未响应的请求时会一直等待，可能会导致整个程序执行时间过长或出现假死状态。\n为了优化fetchall的行为，可以考虑采用并发的方式发送请求，从而避免阻塞等待问题。可以使用 Goroutines 和通道来实现并发请求，从而提高程序的效率。在并发的情况下，当某个请求超时或出现问题时，其他请求仍可以继续执行，不会受到阻塞。这样可以更好地利用系统资源，并加快整体请求的处理速度。\n以下是一个简单的示例代码，展示了如何使用 Goroutines 和通道来并发地发送请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) func fetch(url string, ch chan\u0026lt;- string) { start := time.Now() resp, err := http.Get(url) if err != nil { ch \u0026lt;- fmt.Sprintf(\u0026#34;fetch error: %s %v\u0026#34;, url, err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { ch \u0026lt;- fmt.Sprintf(\u0026#34;read error: %s %v\u0026#34;, url, err) return } ch \u0026lt;- fmt.Sprintf(\u0026#34;%.2fs %s\u0026#34;, time.Since(start).Seconds(), b) } func main() { start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] { go fetch(url, ch) } for range os.Args[1:] { fmt.Println(\u0026lt;-ch) } fmt.Printf(\u0026#34;Total time: %.2fs\\n\u0026#34;, time.Since(start).Seconds()) } 在这个示例中，fetch函数被并发地调用，并使用通道ch来收集每个请求的结果。当一个请求完成时，它会将结果发送到通道中，然后主函数从通道中接收结果并打印。这样，即使其中某个请求没有回应，其他请求仍然可以继续执行，不会出现阻塞等待的情况。\nA WebServer\r示例代码为一个简单的Web服务器程序。由于go标准库实现了大量的工作，我们只需写少数代码即可实现服务器。课后练习如下\n练习 1.12： 修改Lissajour服务，从URL读取变量，比如你可以访问 http://localhost:8000/?cycles=20 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。\n思路\n解析url中的cycles参数，然后改变lissajour函数，将cycles参数传入其中，就可以变化gif图形\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { handler := func(w http.ResponseWriter, r *http.Request) { var cycles string for k, v := range r.Form { if k == \u0026#34;cycles\u0026#34; { cycles = v[0] } } cycles_int, err := strconv.Atoi(cycles) if err != nil { cycles_int = 5 } lissajous(w, cycles_int) } http.HandleFunc(\u0026#34;/\u0026#34;, handler) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } ","date":"2023-07-27T00:00:00Z","image":"http://localhost:1313/p/the-go-programming-language-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-ch.1/ab638d52-5f92-4e29-955e-064deb1c4728_hu_42190784e75fa0e4.jpeg","permalink":"http://localhost:1313/p/the-go-programming-language-%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-ch.1/","title":"The Go Programming Language 课后练习 Ch.1"}]